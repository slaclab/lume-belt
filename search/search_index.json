{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LUME-EBLT","text":"<p>This is a LUME Python interface to EBLT</p>"},{"location":"api/eblt/","title":"Eblt","text":""},{"location":"api/eblt/#eblt.run","title":"eblt.run","text":""},{"location":"api/eblt/#eblt.run-classes","title":"Classes","text":""},{"location":"api/eblt/#eblt.run.EBLT","title":"eblt.run.EBLT","text":"<pre><code>EBLT(input=None, lattice='', *, workdir=None, output=None, alias=None, units=None, command=None, command_mpi=None, use_mpi=False, mpi_run='', use_temp_dir=True, verbose=tools.global_display_options.verbose &gt;= 1, timeout=None, initial_particles=None, initial_field=None, **kwargs)\n</code></pre> <p>               Bases: <code>CommandWrapper</code></p> Source code in <code>eblt/run.py</code> <pre><code>def __init__(\n    self,\n    input: Optional[Union[MainInput, EBLTInput, str, pathlib.Path]] = None,\n    lattice: Union[Lattice, str, pathlib.Path] = \"\",\n    *,\n    workdir: Optional[Union[str, pathlib.Path]] = None,\n    output: Optional[EBLTOutput] = None,\n    alias: Optional[Dict[str, str]] = None,\n    units: Optional[Dict[str, pmd_unit]] = None,\n    command: Optional[str] = None,\n    command_mpi: Optional[str] = None,\n    use_mpi: bool = False,\n    mpi_run: str = \"\",\n    use_temp_dir: bool = True,\n    verbose: bool = tools.global_display_options.verbose &gt;= 1,\n    timeout: Optional[float] = None,\n    initial_particles: Optional[Union[ParticleGroup, EBLTParticleData]] = None,\n    initial_field: Optional[FieldFile] = None,\n    **kwargs: Any,\n):\n    super().__init__(\n        command=command,\n        command_mpi=command_mpi,\n        use_mpi=use_mpi,\n        mpi_run=mpi_run,\n        use_temp_dir=use_temp_dir,\n        workdir=workdir,\n        verbose=verbose,\n        timeout=timeout,\n        **kwargs,\n    )\n\n    if input is None:\n        input = EBLTInput(\n            main=MainInput(),\n            lattice=Lattice(),\n            initial_particles=initial_particles,\n        )\n    elif isinstance(input, MainInput):\n        input = EBLTInput.from_main_input(\n            main=input,\n            lattice=lattice,\n            source_path=pathlib.Path(workdir or \".\"),\n        )\n    elif not isinstance(input, EBLTInput):\n        # We have either a string or a filename for our main input.\n        workdir, input = _make_eblt_input(\n            input,\n            lattice,\n            source_path=workdir,\n        )\n\n    if (\n        input.initial_particles is not initial_particles\n        and initial_particles is not None\n    ):\n        input.initial_particles = initial_particles\n\n    if input.initial_field is not initial_field and initial_field is not None:\n        input.initial_field = initial_field\n\n    if workdir is None:\n        workdir = pathlib.Path(\".\")\n\n    self.original_path = workdir\n    self._input = input\n    self.output = output\n\n    # Internal\n    self._units = dict(units or parsers.known_unit)\n    self._alias = dict(alias or {})\n\n    # MPI\n    self.nproc = 1\n    self.nnode = 1\n</code></pre>"},{"location":"api/eblt/#eblt.run.EBLT-attributes","title":"Attributes","text":"eblt.run.EBLT.initial_particles <code>property</code> <code>writable</code> \u00b6 <pre><code>initial_particles\n</code></pre> <p>Initial particles, if defined.  Property is alias for <code>.input.main.initial_particles</code>.</p> eblt.run.EBLT.input <code>property</code> <code>writable</code> \u00b6 <pre><code>input\n</code></pre> <p>EBLT input</p> eblt.run.EBLT.nproc <code>property</code> <code>writable</code> \u00b6 <pre><code>nproc\n</code></pre> <p>Number of MPI processes to use.</p>"},{"location":"api/eblt/#eblt.run.EBLT-functions","title":"Functions","text":"eblt.run.EBLT.archive \u00b6 <pre><code>archive(dest)\n</code></pre> <p>Archive the latest run, input and output, to a single HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>filename or Group</code> required Source code in <code>eblt/run.py</code> <pre><code>@override\ndef archive(self, dest: Union[AnyPath, h5py.Group]) -&gt; None:\n    \"\"\"\n    Archive the latest run, input and output, to a single HDF5 file.\n\n    Parameters\n    ----------\n    dest : filename or h5py.Group\n    \"\"\"\n    if isinstance(dest, (str, pathlib.Path)):\n        with h5py.File(dest, \"w\") as fp:\n            self._archive(fp)\n    elif isinstance(dest, (h5py.File, h5py.Group)):\n        self._archive(dest)\n</code></pre> eblt.run.EBLT.configure \u00b6 <pre><code>configure()\n</code></pre> <p>Configure and set up for run.</p> Source code in <code>eblt/run.py</code> <pre><code>@override\ndef configure(self):\n    \"\"\"\n    Configure and set up for run.\n    \"\"\"\n    self.setup_workdir(self._workdir)\n    self.vprint(\"Configured to run in:\", self.path)\n    self.configured = True\n    self.finished = False\n</code></pre> eblt.run.EBLT.from_archive <code>classmethod</code> \u00b6 <pre><code>from_archive(arch)\n</code></pre> <p>Create a new Genesis4 object from an archive file.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>filename or Group</code> required Source code in <code>eblt/run.py</code> <pre><code>@override\n@classmethod\ndef from_archive(cls, arch: Union[AnyPath, h5py.Group]) -&gt; EBLT:\n    \"\"\"\n    Create a new Genesis4 object from an archive file.\n\n    Parameters\n    ----------\n    arch : filename or h5py.Group\n    \"\"\"\n    inst = cls()\n    inst.load_archive(arch)\n    return inst\n</code></pre> eblt.run.EBLT.get_executable \u00b6 <pre><code>get_executable()\n</code></pre> <p>Gets the full path of the executable from .command, .command_mpi Will search environmental variables:         Genesis4.command_env='GENESIS4_BIN'         Genesis4.command_mpi_env='GENESIS4_BIN'</p> Source code in <code>eblt/run.py</code> <pre><code>def get_executable(self):\n    \"\"\"\n    Gets the full path of the executable from .command, .command_mpi\n    Will search environmental variables:\n            Genesis4.command_env='GENESIS4_BIN'\n            Genesis4.command_mpi_env='GENESIS4_BIN'\n    \"\"\"\n    if self.use_mpi:\n        return lume_tools.find_executable(\n            exename=self.command_mpi, envname=self.command_mpi_env\n        )\n    return lume_tools.find_executable(\n        exename=self.command, envname=self.command_env\n    )\n</code></pre> eblt.run.EBLT.get_run_prefix \u00b6 <pre><code>get_run_prefix()\n</code></pre> <p>Get the command prefix to run Genesis (e.g., 'mpirun' or 'genesis4').</p> Source code in <code>eblt/run.py</code> <pre><code>def get_run_prefix(self) -&gt; str:\n    \"\"\"Get the command prefix to run Genesis (e.g., 'mpirun' or 'genesis4').\"\"\"\n    exe = self.get_executable()\n\n    if self.nproc != 1 and not self.use_mpi:\n        self.vprint(f\"Setting use_mpi = True because nproc = {self.nproc}\")\n        self.use_mpi = True\n\n    if self.use_mpi:\n        return self.mpi_run.format(\n            nnode=self.nnode, nproc=self.nproc, command_mpi=exe\n        )\n    return exe\n</code></pre> eblt.run.EBLT.get_run_script \u00b6 <pre><code>get_run_script(write_to_path=True)\n</code></pre> <p>Assembles the run script using self.mpi_run string of the form:     'mpirun -n {n} {command_mpi}' Optionally writes a file 'run' with this line to path.</p> <p>mpi_exe could be a complicated string like:     'srun -N 1 --cpu_bind=cores {n} {command_mpi}'     or     'mpirun -n {n} {command_mpi}'</p> Source code in <code>eblt/run.py</code> <pre><code>@override\ndef get_run_script(self, write_to_path: bool = True) -&gt; str:\n    \"\"\"\n    Assembles the run script using self.mpi_run string of the form:\n        'mpirun -n {n} {command_mpi}'\n    Optionally writes a file 'run' with this line to path.\n\n    mpi_exe could be a complicated string like:\n        'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n        or\n        'mpirun -n {n} {command_mpi}'\n    \"\"\"\n    if self.path is None:\n        raise ValueError(\"path (base_path) not yet set\")\n\n    runscript = shlex.join(\n        [\n            *shlex.split(self.get_run_prefix()),\n            *self.input.arguments,\n        ]\n    )\n\n    if write_to_path:\n        self.write_run_script()\n\n    return runscript\n</code></pre> eblt.run.EBLT.input_parser <code>staticmethod</code> \u00b6 <pre><code>input_parser(path)\n</code></pre> <p>Invoke the specialized main input parser and returns the <code>MainInput</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the main input file.</p> required <p>Returns:</p> Type Description <code>MainInput</code> Source code in <code>eblt/run.py</code> <pre><code>@override\n@staticmethod\ndef input_parser(path: AnyPath) -&gt; MainInput:\n    \"\"\"\n    Invoke the specialized main input parser and returns the `MainInput`\n    instance.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path\n        Path to the main input file.\n\n    Returns\n    -------\n    MainInput\n    \"\"\"\n    return MainInput.from_file(path)\n</code></pre> eblt.run.EBLT.lattice_parser <code>staticmethod</code> \u00b6 <pre><code>lattice_parser(path)\n</code></pre> <p>Invoke the specialized lattice input parser and returns the <code>Lattice</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the lattice input file.</p> required <p>Returns:</p> Type Description <code>Lattice</code> Source code in <code>eblt/run.py</code> <pre><code>@staticmethod\ndef lattice_parser(path: AnyPath) -&gt; Lattice:\n    \"\"\"\n    Invoke the specialized lattice input parser and returns the `Lattice`\n    instance.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path\n        Path to the lattice input file.\n\n    Returns\n    -------\n    Lattice\n    \"\"\"\n    return Lattice.from_file(path)\n</code></pre> eblt.run.EBLT.load_archive \u00b6 <pre><code>load_archive(arch)\n</code></pre> <p>Load an archive from a single HDF5 file into this Genesis4 object.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>filename or Group</code> required Source code in <code>eblt/run.py</code> <pre><code>@override\ndef load_archive(self, arch: Union[AnyPath, h5py.Group]) -&gt; None:\n    \"\"\"\n    Load an archive from a single HDF5 file into this Genesis4 object.\n\n    Parameters\n    ----------\n    arch : filename or h5py.Group\n    \"\"\"\n    if isinstance(arch, (str, pathlib.Path)):\n        with h5py.File(arch, \"r\") as fp:\n            self._load_archive(fp)\n    elif isinstance(arch, (h5py.File, h5py.Group)):\n        self._load_archive(arch)\n</code></pre> eblt.run.EBLT.run \u00b6 <pre><code>run(load_particles=False, raise_on_error=True)\n</code></pre> <p>Execute EBLT 4 with the configured input settings.</p> <p>Parameters:</p> Name Type Description Default <code>load_fields</code> <code>bool</code> <p>After execution, load all field files.</p> <code>False</code> <code>load_particles</code> <code>bool</code> <p>After execution, load all particle files.</p> <code>False</code> <code>smear</code> <code>bool</code> <p>If set, for particles, this will smear the phase over the sample (skipped) slices, preserving the modulus.</p> <code>True</code> <code>raise_on_error</code> <code>bool</code> <p>If EBLT 4 fails to run, raise an error. Depending on the error, output information may still be accessible in the <code>.output</code> attribute.</p> <code>True</code> <p>Returns:</p> Type Description <code>EBLTOutput</code> <p>The output data.  This is also accessible as <code>.output</code>.</p> Source code in <code>eblt/run.py</code> <pre><code>@override\ndef run(\n    self,\n    load_particles: bool = False,\n    raise_on_error: bool = True,\n) -&gt; EBLTOutput:\n    \"\"\"\n    Execute EBLT 4 with the configured input settings.\n\n    Parameters\n    ----------\n    load_fields : bool, default=False\n        After execution, load all field files.\n    load_particles : bool, default=False\n        After execution, load all particle files.\n    smear : bool, default=True\n        If set, for particles, this will smear the phase over the sample\n        (skipped) slices, preserving the modulus.\n    raise_on_error : bool, default=True\n        If EBLT 4 fails to run, raise an error. Depending on the error,\n        output information may still be accessible in the ``.output``\n        attribute.\n\n    Returns\n    -------\n    EBLTOutput\n        The output data.  This is also accessible as ``.output``.\n    \"\"\"\n    if not self.configured:\n        self.configure()\n\n    if self.path is None:\n        raise ValueError(\"Path (base_path) not yet set\")\n\n    self.finished = False\n\n    runscript = self.get_run_script()\n\n    start_time = monotonic()\n    self.vprint(f\"Running EBLT in {self.path}\")\n    self.vprint(runscript)\n\n    self.write_input()\n\n    if self.timeout:\n        self.vprint(\n            f\"Timeout of {self.timeout} is being used; output will be \"\n            f\"displaye after EBLT exits.\"\n        )\n        execute_result = tools.execute2(\n            shlex.split(runscript),\n            timeout=self.timeout,\n            cwd=self.path,\n        )\n        self.vprint(execute_result[\"log\"])\n    else:\n        log = []\n        try:\n            for line in tools.execute(shlex.split(runscript), cwd=self.path):\n                self.vprint(line, end=\"\")\n                log.append(line)\n        except Exception as ex:\n            log.append(f\"EBLT exited with an error: {ex}\")\n            self.vprint(log[-1])\n            execute_result = {\n                \"log\": \"\".join(log),\n                \"error\": True,\n                \"why_error\": \"error\",\n            }\n        else:\n            execute_result = {\n                \"log\": \"\".join(log),\n                \"error\": False,\n                \"why_error\": \"\",\n            }\n\n    end_time = monotonic()\n\n    self.finished = True\n    run_info = RunInfo(\n        run_script=runscript,\n        error=execute_result[\"error\"],\n        error_reason=execute_result[\"why_error\"],\n        start_time=start_time,\n        end_time=end_time,\n        run_time=end_time - start_time,\n        output_log=execute_result[\"log\"],\n    )\n\n    success_or_failure = \"Success\" if not execute_result[\"error\"] else \"Failure\"\n    self.vprint(f\"{success_or_failure} - execution took {run_info.run_time:0.2f}s.\")\n\n    try:\n        self.output = self.load_output()\n\n    except Exception as ex:\n        stack = traceback.format_exc()\n        run_info.error = True\n        run_info.error_reason = (\n            f\"Failed to load output file. {ex.__class__.__name__}: {ex}\\n{stack}\"\n        )\n        self.output = EBLTOutput(run=run_info)\n        if hasattr(ex, \"add_note\"):\n            # Python 3.11+\n            ex.add_note(\n                f\"\\nEBLT output was:\\n\\n{execute_result['log']}\\n(End of EBLT output)\"\n            )\n        if raise_on_error:\n            raise\n\n    self.output.run = run_info\n    if run_info.error and raise_on_error:\n        raise EBLTRunFailure(f\"EBLT failed to run: {run_info.error_reason}\")\n\n    return self.output\n</code></pre> eblt.run.EBLT.write_input \u00b6 <pre><code>write_input(path=None, write_run_script=True)\n</code></pre> <p>Write the input parameters into the file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory to write the input parameters</p> <code>None</code> Source code in <code>eblt/run.py</code> <pre><code>@override\ndef write_input(\n    self,\n    path: Optional[AnyPath] = None,\n    write_run_script: bool = True,\n):\n    \"\"\"\n    Write the input parameters into the file.\n\n    Parameters\n    ----------\n    path : str, optional\n        The directory to write the input parameters\n    \"\"\"\n    if not self.configured:\n        self.configure()\n\n    if path is None:\n        path = self.path\n\n    if path is None:\n        raise ValueError(\"Path has not yet been set; cannot write input.\")\n\n    path = pathlib.Path(path)\n    self.input.write(workdir=path)\n    if write_run_script:\n        self.write_run_script(path)\n</code></pre> eblt.run.EBLT.write_run_script \u00b6 <pre><code>write_run_script(path=None)\n</code></pre> <p>Write the 'run' script which can be used in a terminal to launch Genesis.</p> <p>This is also performed automatically in <code>write_input</code> and <code>get_run_script</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path or str</code> <p>Where to write the run script.  Defaults to <code>{self.path}/run</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>The run script location.</p> Source code in <code>eblt/run.py</code> <pre><code>def write_run_script(self, path: Optional[AnyPath] = None) -&gt; pathlib.Path:\n    \"\"\"\n    Write the 'run' script which can be used in a terminal to launch Genesis.\n\n    This is also performed automatically in `write_input` and\n    `get_run_script`.\n\n    Parameters\n    -------\n    path : pathlib.Path or str\n        Where to write the run script.  Defaults to `{self.path}/run`.\n\n    Returns\n    -------\n    pathlib.Path\n        The run script location.\n    \"\"\"\n    path = path or self.path\n    if path is None:\n        raise ValueError(\"path (base_path) not yet set and no path specified\")\n\n    path = pathlib.Path(path)\n    if path.is_dir():\n        path = path / \"run\"\n\n    self.input.write_run_script(\n        path,\n        command_prefix=self.get_run_prefix(),\n    )\n    logger.debug(\"Wrote run script to %s\", path)\n    return path\n</code></pre>"},{"location":"api/eblt/#eblt.run-functions","title":"Functions","text":""},{"location":"api/eblt/#eblt.run.find_mpirun","title":"eblt.run.find_mpirun","text":"<pre><code>find_mpirun()\n</code></pre> <p>Simple helper to find the mpi run command for macports and homebrew, as well as custom commands for Perlmutter at NERSC.</p> Source code in <code>eblt/run.py</code> <pre><code>def find_mpirun():\n    \"\"\"\n    Simple helper to find the mpi run command for macports and homebrew,\n    as well as custom commands for Perlmutter at NERSC.\n    \"\"\"\n\n    for p in [\n        # Highest priority is what our PATH says:\n        shutil.which(\"mpirun\"),\n        # Second, macports:\n        \"/opt/local/bin/mpirun\",\n        # Third, homebrew:\n        \"/opt/homebrew/bin/mpirun\",\n    ]:\n        if p and os.path.exists(p):\n            return f'\"{p}\"' + \" -n {nproc} {command_mpi}\"\n\n    if os.environ.get(\"NERSC_HOST\") == \"perlmutter\":\n        srun = \"srun -n {nproc} --ntasks-per-node {nproc} -c 1 {command_mpi}\"\n        hostname = platform.node()\n        assert hostname  # This must exist\n        if hostname.startswith(\"nid\"):\n            # Compute node\n            return srun\n        else:\n            # This will work on a login node\n            return \"salloc -N {nnode} -C cpu -q interactive -t 04:00:00 \" + srun\n\n    # Default\n    return \"mpirun -n {nproc} {command_mpi}\"\n</code></pre>"},{"location":"examples/eblt_devel/","title":"LUME-EBLT devel","text":"In\u00a0[\u00a0]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[\u00a0]: Copied! <pre>from eblt.input import EBLTInput, assign_names_to_elements\nfrom eblt.output import EBLTOutput\nfrom eblt.plot import plot_lattice_lines\n\nimport numpy as np\n\nfrom pmd_beamphysics import ParticleGroup\nfrom pmd_beamphysics.units import mec2\nimport rich\nimport matplotlib.pyplot as plt\n</pre> from eblt.input import EBLTInput, assign_names_to_elements from eblt.output import EBLTOutput from eblt.plot import plot_lattice_lines  import numpy as np  from pmd_beamphysics import ParticleGroup from pmd_beamphysics.units import mec2 import rich import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre>input = EBLTInput.from_file(\"example1/eblt.in\")\nassign_names_to_elements(input.lattice_lines)\n</pre> input = EBLTInput.from_file(\"example1/eblt.in\") assign_names_to_elements(input.lattice_lines) In\u00a0[\u00a0]: Copied! <pre>rich.print(input)\n</pre> rich.print(input) In\u00a0[\u00a0]: Copied! <pre>plot_lattice_lines(input.lattice_lines)\n</pre> plot_lattice_lines(input.lattice_lines) In\u00a0[\u00a0]: Copied! <pre>input.to_file(\"test/eblt.in\")\n</pre> input.to_file(\"test/eblt.in\") In\u00a0[\u00a0]: Copied! <pre>!mkdir test\n!cd test;cp ../example1/rfdata* .;cp ../example1/pts.in .;\n</pre> !mkdir test !cd test;cp ../example1/rfdata* .;cp ../example1/pts.in .; In\u00a0[\u00a0]: Copied! <pre>!cd test;$EBLT_EXE &gt;log.txt;head log.txt;tail log.txt\n</pre> !cd test;$EBLT_EXE &gt;log.txt;head log.txt;tail log.txt In\u00a0[\u00a0]: Copied! <pre>output = EBLTOutput.from_directory(\"test\")\noutput.stats.model_fields.keys()\n</pre> output = EBLTOutput.from_directory(\"test\") output.stats.model_fields.keys() In\u00a0[\u00a0]: Copied! <pre>output.stats.model_fields\n</pre> output.stats.model_fields In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(output.stats.distance, output.stats.kinetic_energy / 1e6, color=\"red\")\nax.set_xlabel(r\"$s$ (m)\")\nax.set_ylabel(r\"$E_\\text{kinetic}$ (MeV)\")\nax.set_ylim(0, None)\n</pre> fig, ax = plt.subplots() ax.plot(output.stats.distance, output.stats.kinetic_energy / 1e6, color=\"red\") ax.set_xlabel(r\"$s$ (m)\") ax.set_ylabel(r\"$E_\\text{kinetic}$ (MeV)\") ax.set_ylim(0, None) In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(output.stats.distance, output.stats.rms_z * 1e3, color=\"blue\")\nax.set_xlabel(r\"$s$ (m)\")\nax.set_ylabel(r\"$\\sigma_z$ (mm)\")\nax.set_ylim(0, None)\n</pre> fig, ax = plt.subplots() ax.plot(output.stats.distance, output.stats.rms_z * 1e3, color=\"blue\") ax.set_xlabel(r\"$s$ (m)\") ax.set_ylabel(r\"$\\sigma_z$ (mm)\") ax.set_ylim(0, None) In\u00a0[\u00a0]: Copied! <pre>p = output.particle_distributions[201]\nplt.scatter(p.z, p.delta_gamma)\n</pre> p = output.particle_distributions[201] plt.scatter(p.z, p.delta_gamma) In\u00a0[\u00a0]: Copied! <pre>def particlegroup_data_from_eblt(p):\n    z = p.z\n    gamma = p.gamma\n    weight = p.weight\n    n = len(z)\n    pz = np.sqrt(gamma**2 - 1) * mec2\n    return dict(\n        t=np.zeros(n),\n        x=np.zeros(n),\n        px=np.zeros(n),\n        y=np.zeros(n),\n        py=np.zeros(n),\n        z=p.z,\n        pz=pz,\n        weight=weight,\n        status=np.ones(n),\n        species=\"electron\",\n    )\n\n\nP = ParticleGroup(data=particlegroup_data_from_eblt(p))\n\nP.plot(\"z\", \"energy\", bins=100)\n</pre> def particlegroup_data_from_eblt(p):     z = p.z     gamma = p.gamma     weight = p.weight     n = len(z)     pz = np.sqrt(gamma**2 - 1) * mec2     return dict(         t=np.zeros(n),         x=np.zeros(n),         px=np.zeros(n),         y=np.zeros(n),         py=np.zeros(n),         z=p.z,         pz=pz,         weight=weight,         status=np.ones(n),         species=\"electron\",     )   P = ParticleGroup(data=particlegroup_data_from_eblt(p))  P.plot(\"z\", \"energy\", bins=100)"},{"location":"examples/eblt_devel/#lume-eblt-devel","title":"LUME-EBLT devel\u00b6","text":""},{"location":"examples/eblt_devel/#load-input-file","title":"Load input file\u00b6","text":""},{"location":"examples/eblt_devel/#view-input","title":"View input\u00b6","text":""},{"location":"examples/eblt_devel/#plot-lattice","title":"Plot lattice\u00b6","text":""},{"location":"examples/eblt_devel/#write-input-for-testing","title":"Write input for testing\u00b6","text":"<p>TODO: parsing rfdata, pts.in</p>"},{"location":"examples/eblt_devel/#run-manually","title":"Run manually\u00b6","text":""},{"location":"examples/eblt_devel/#load-output","title":"Load output\u00b6","text":""},{"location":"examples/eblt_devel/#particles","title":"Particles\u00b6","text":""}]}